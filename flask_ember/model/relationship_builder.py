from sqlalchemy.orm import relationship
from sqlalchemy.sql.expression import and_
from sqlalchemy.sql.schema import Column, ForeignKeyConstraint

from .property_builder_base import PropertyBuilderBase


class RelationshipBuilder(PropertyBuilderBase):
    def __init__(self, use_list, *args, **kwargs):
        self.use_list = use_list
        self.primary_join_clauses = list()
        super().__init__(*args, **kwargs)

    @property
    def target(self):
        return self.resource_property.target

    @property
    def inverse(self):
        return self.resource_property.inverse

    @property
    def inverse_builder(self):
        return self.inverse.builder

    @property
    def target_table(self):
        return self.target._table

    @property
    def backref(self):
        # The backref of the underlying property may be set while initializing
        # the resource. Therefore it has to be evaluated lazily.
        return self.resource_property.backref

    @property
    def generate_foreign_key(self):
        # Whether foreign keys are generated by this side is not determined
        # for one-to-one relationships when this builder is created.
        # Therefore it has to be evaluated lazily from the underlying property.
        return self.resource_property.is_many_side

    def get_relation_kwargs(self):
        kwargs = {
            'lazy': 'dynamic' if self.use_list else 'select',
            'uselist': self.use_list,
            'back_populates': self.backref
        }
        clause_source = (self if self.generate_foreign_key else
                         self.inverse_builder)
        kwargs['primaryjoin'] = and_(*clause_source.primary_join_clauses)

        if self.table == self.target_table and not self.generate_foreign_key:
            kwargs['remote_side'] = [column for column in
                                     self.table.primary_key.columns]
        return kwargs

    def create_non_primary_key_columns(self):
        if not self.generate_foreign_key:
            return

        primary_columns = self.target_table.primary_key.columns
        if not primary_columns:
            raise Exception("No primary key found in table "
                            "'{}' ".format(self.target_table.fullname))

        foreign_key_names = list()
        foreign_key_ref_names = list()

        for primary_column in primary_columns:
            column_name = '{}_{}'.format(self.target_table.fullname,
                                         primary_column.key)
            column = Column(column_name, primary_column.type)
            self.builder.add_column(column)

            foreign_key_names.append(column.key)
            foreign_key_ref_names.append('{}.{}'.format(
                self.target_table.fullname, primary_column.key))
            self.primary_join_clauses.append(column == primary_column)

        foreign_key_name = '_'.join(foreign_key_names)
        constraint_name = '{}_{}_fk'.format(self.table.fullname,
                                            foreign_key_name)
        constraint = ForeignKeyConstraint(foreign_key_names,
                                          foreign_key_ref_names,
                                          name=constraint_name)
        self.builder.add_constraint(constraint)

    def create_properties(self):
        relation_kwargs = self.get_relation_kwargs()
        relation = relationship(self.target, **relation_kwargs)
        self.add_mapper_property(self.name, relation)
