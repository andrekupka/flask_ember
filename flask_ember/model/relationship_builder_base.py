from sqlalchemy.orm import relationship

from .property_builder_base import PropertyBuilderBase


class RelationshipBuilderBase(PropertyBuilderBase):
    def __init__(self, use_list, **kwargs):
        self.use_list = use_list
        super().__init__(**kwargs)

    @property
    def target(self):
        return self.resource_property.target

    @property
    def inverse(self):
        return self.resource_property.inverse

    @property
    def target_table(self):
        return self.target._table

    @property
    def backref(self):
        # The backref of the underlying property may be set while initializing
        # the resource. Therefore it has to be evaluated lazily.
        return self.resource_property.backref

    @property
    def generate_foreign_key(self):
        # Whether foreign keys are generated by this side is not determined
        # for one-to-one relationships when this builder is created.
        # Therefore it has to be evaluated lazily from the underlying property.
        return self.resource_property.is_many_side

    def get_relation_arguments(self):
        kwargs = {
            'lazy': 'dynamic' if self.use_list else 'select',
            'uselist': self.use_list,
            'back_populates': self.backref
        }
        return kwargs

    def create_properties(self):
        relation_kwargs = self.get_relation_arguments()
        relation = relationship(self.target, **relation_kwargs)
        self.add_mapper_property(self.name, relation)
